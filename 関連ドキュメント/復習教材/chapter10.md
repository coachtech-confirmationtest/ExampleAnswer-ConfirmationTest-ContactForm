# Chapter 10: 応用機能 - タグ機能のマイグレーション

## 🎯 このセクションで学ぶこと

ここから応用機能の実装に入ります。最初のステップとして、お問い合わせに複数の「タグ」を付けられるようにする機能を実装します。例えば、「緊急」「要返信」「クレーム」といったタグを付けることで、お問い合わせの分類や管理が格段に効率化されます。このチャプターでは、その第一歩として、タグ機能を実現するために必要なデータベースのテーブル設計と、その設計図である「マイグレーション」の作成方法を学びます。特に、一つの問い合わせに複数のタグを、一つのタグが複数の問い合わせに紐づく「**多対多リレーション**」という重要な概念を深く理解することがゴールです。

## 1. はじめに 📖

### なぜタグ機能が必要なのか？

基本機能でお問い合わせの「カテゴリー」を実装しましたが、これはあくまで「商品について」「店舗について」といった大きな分類です。実際の運用では、もっと柔軟で動的な分類が必要になる場面が多くあります。例えば、

- 至急対応が必要な問い合わせに「緊急」タグを付ける
- 返信がまだの問い合わせに「未返信」タグを付ける
- 特定のキャンペーンに関する問い合わせを「キャンペーンA」タグでまとめる

このように、タグ機能は静的なカテゴリーとは異なり、状況に応じて後から自由に追加・削除できる動的なラベルとして機能します。これにより、膨大なお問い合わせの中から特定の条件に合致するものを素早く見つけ出したり、対応の優先順位を付けたりすることが可能になり、サポート業務の質と効率を大幅に向上させることができます。

### 多対多リレーションとは？

このタグ機能を実現する上で鍵となるのが「多対多（Many-to-Many）」リレーションです。これまでの「カテゴリー」と「お問い合わせ」の関係は、一つの問い合わせが一つのカテゴリーに属する「一対多（One-to-Many）」の関係でした。しかし、タグの場合は異なります。

- 一つのお問い合わせ（Contact）は、複数のタグ（Tag）を持つことができる（例：「緊急」と「要返信」）。
- 一つのタグ（Tag）は、複数のお問い合わせ（Contact）に紐づくことができる（例：「緊急」タグが複数の問い合わせに付いている）。

このような関係性を「多対多」と呼びます。この関係をデータベースで表現するためには、`contacts`テーブルと`tags`テーブルに加えて、両者の関係を管理するための「**中間テーブル**（`contact_tag`）」が必要になります。このチャプターでは、この中間テーブルを含む3つのテーブルの構造を設計し、マイグレーションとしてコードに落とし込んでいきます。

## 2. 要件の確認 📋

タグ機能を実現するために必要なデータベーステーブルの具体的な仕様を整理します。

### `tags`テーブル

タグ自体の情報を格納するテーブルです。

| カラム名 | データ型 | 制約 | 役割 |
| :--- | :--- | :--- | :--- |
| `id` | `bigIncrements` | 主キー | タグの一意なID。 |
| `name` | `string(50)` | `unique` | タグの名前（例：「緊急」「質問」）。重複は許さない。 |
| `created_at` | `timestamp` | `nullable` | 作成日時。 |
| `updated_at` | `timestamp` | `nullable` | 更新日時。 |

### `contact_tag`テーブル（中間テーブル）

`contacts`テーブルと`tags`テーブルの多対多の関係を定義するための中間テーブルです。

| カラム名 | データ型 | 制約 | 役割 |
| :--- | :--- | :--- | :--- |
| `id` | `bigIncrements` | 主キー | このリレーションの一意なID。 |
| `contact_id` | `foreignId` | `constrained`, `onDelete('cascade')` | `contacts`テーブルのIDへの外部キー。問い合わせが削除されたら、このレコードも自動で削除される。 |
| `tag_id` | `foreignId` | `constrained`, `onDelete('cascade')` | `tags`テーブルのIDへの外部キー。タグが削除されたら、このレコードも自動で削除される。 |
| `created_at` | `timestamp` | `nullable` | 作成日時。 |
| `updated_at` | `timestamp` | `nullable` | 更新日時。 |
| (`contact_id`, `tag_id`) | - | `unique` | 同じ問い合わせに同じタグが複数紐づくことを防ぐ複合ユニークキー。 |

## 3. 先輩エンジニアの思考プロセス 💭

多対多リレーションを設計する際、経験豊富なエンジニアはどのような点を考慮するのでしょうか。

### Point 1: なぜ中間テーブルが必要なのか？

リレーショナルデータベースの基本的なルールとして、一つのカラムには一つの値しか格納できません。もし中間テーブルを使わずに`contacts`テーブルに`tag_ids`のようなカラムを作って`1,5,10`のようにカンマ区切りでIDを保存しようとすると、検索が非常に困難になり、データの整合性を保つことも難しくなります。これはアンチパターンです。そこで、`contacts`と`tags`の関係性を表現するためだけのテーブル、つまり中間テーブルを導入します。このテーブルの各行は「どの問い合わせ」が「どのタグ」に紐づいているかという単一の事実のみを記録します。これにより、データベースの正規化が保たれ、柔軟で効率的なデータ操作が可能になるのです。

### Point 2: 中間テーブルの命名規則をどうするか？

Laravelには「設定より規約」の文化が根付いています。中間テーブルの命名にも推奨される規約があります。それは、「**関連する2つのテーブル名を、単数形で、アルファベット順に並べ、アンダースコアで繋ぐ**」というものです。今回の場合、`contact`と`tag`なので、アルファベット順に並べると`contact_tag`となります。この規約に従うことで、後のモデルリレーション定義でLaravelが自動的に中間テーブル名を推測してくれるため、余計な設定を記述する必要がなくなります。

### Point 3: 外部キー制約は必ず設定する

中間テーブルの`contact_id`と`tag_id`には、必ず外部キー制約を設定します。これは、データベースレベルでデータの整合性を保証するための非常に重要な仕組みです。外部キー制約があれば、例えば存在しない`contact_id`を持つ`contact_tag`レコードを作成しようとしても、データベースがエラーを返してくれます。これにより、意図しないデータ（孤児レコード）が生まれるのを防ぎ、アプリケーションの堅牢性を高めることができます。

### Point 4: カスケード削除（`onDelete('cascade')`）を検討する

外部キー制約と合わせて設定を検討すべきなのが「カスケード削除」です。これを設定しておくと、親テーブルのレコード（例: `contacts`テーブルのある問い合わせ）が削除されたときに、それに関連する中間テーブルのレコード（その問い合わせに紐づく全ての`contact_tag`レコード）も自動的に削除されます。これにより、手動で関連レコードを削除する手間が省け、データのクリーンな状態を維持しやすくなります。今回のケースでは、問い合わせやタグが削除されたら、その関連情報も不要になるのが自然なので、カスケード削除を設定するのが適切です。

## 4. 実装 🚀

それでは、実際にマイグレーションファイルを作成し、テーブルのスキーマを定義していきましょう。

### 4.1. `tags`テーブルのマイグレーション作成

まず、`tags`テーブルを作成するためのマイグレーションファイルを生成します。

```bash
sail artisan make:migration create_tags_table
```

生成された`database/migrations/xxxx_xx_xx_xxxxxx_create_tags_table.php`ファイルを以下のように編集します。

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('tags', function (Blueprint $table) {
            $table->id();
            $table->string('name', 50)->unique();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('tags');
    }
};
```

### 4.2. `contact_tag`中間テーブルのマイグレーション作成

次に、中間テーブル`contact_tag`を作成するためのマイグレーションファイルを生成します。

```bash
sail artisan make:migration create_contact_tag_table
```

生成された`database/migrations/xxxx_xx_xx_xxxxxx_create_contact_tag_table.php`ファイルを以下のように編集します。

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('contact_tag', function (Blueprint $table) {
            $table->id();
            $table->foreignId('contact_id')->constrained()->onDelete('cascade');
            $table->foreignId('tag_id')->constrained()->onDelete('cascade');
            $table->timestamps();

            // 同一の組み合わせが複数登録されることを防ぐ
            $table->unique(['contact_id', 'tag_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('contact_tag');
    }
};
```

### 4.3. マイグレーションの実行

作成した2つのマイグレーションファイルを実行して、データベースにテーブルを作成します。

```bash
sail artisan migrate
```

このコマンドを実行後、phpMyAdminなどでデータベースを確認し、`tags`テーブルと`contact_tag`テーブルが正しく作成されていることを確認してください。

## 5. コードの詳細解説 🔍

### `..._create_tags_table.php` の解説

- **`Schema::create('tags', ...)`**: `tags`という名前の新しいテーブルを作成します。
- **`$table->id();`**: `id`という名前の主キーカラム（`UNSIGNED BIGINT`, `AUTO_INCREMENT`）を作成します。これは`$table->bigIncrements('id');`のショートカットです。
- **`$table->string('name', 50)->unique();`**: `name`カラムを`VARCHAR(50)`として定義し、`unique`制約を付けています。これにより、同じ名前のタグが複数登録されるのをデータベースレベルで防ぎます。`50`という長さは、タグ名として十分な長さを確保しつつ、無駄に大きな領域を確保しないためのバランスを考えた設定です。
- **`$table->timestamps();`**: `created_at`と`updated_at`という2つの`TIMESTAMP`型のカラムを自動的に作成します。モデルを通じてデータを操作する際に、作成日時と更新日時が自動的に記録されるようになります。

### `..._create_contact_tag_table.php` の解説

- **`Schema::create('contact_tag', ...)`**: 中間テーブル`contact_tag`を作成します。テーブル名が規約通りなので、Laravelが賢く解釈してくれます。
- **`$table->foreignId('contact_id')->constrained()->onDelete('cascade');`**: この一行は、Laravelのマイグレーションにおける非常に強力なショートカットです。これは以下の処理をまとめて行っています。
    1.  **`foreignId('contact_id')`**: `contact_id`という名前の`UNSIGNED BIGINT`型のカラムを作成します。
    2.  **`constrained()`**: カラム名(`contact_id`)から親テーブルが`contacts`（複数形）、その主キーが`id`であると自動的に推測し、`contacts.id`への外部キー制約を設定します。もしテーブル名が規約通りでない場合は、`constrained('another_table')`のように引数で指定できます。
    3.  **`onDelete('cascade')`**: 親である`contacts`テーブルのレコードが削除された場合、この`contact_tag`テーブルの関連レコードも一緒に削除するよう設定します。データの整合性を保つために非常に重要です。
- **`$table->foreignId('tag_id')->constrained()->onDelete('cascade');`**: `contact_id`と同様に、`tags`テーブルへの外部キー制約とカスケード削除を設定します。
- **`$table->unique(['contact_id', 'tag_id']);`**: これは「複合ユニークキー」を設定しています。`contact_id`と`tag_id`の組み合わせが、テーブル内で常に一意であることを保証します。これにより、例えば「ID:1の問い合わせ」に「ID:5のタグ」が2回以上紐付けられる、といったデータの重複を防ぐことができます。

## 6. How to: この実装にたどり着くための調べ方 🗺️

新しい技術を学ぶ際、AIを「優秀な家庭教師」として活用することで、学習効率を飛躍的に高めることができます。ここでは、4つのステップでAIに質問しながら多対多リレーションをマスターする方法を紹介します。

### Step 1: 公式ドキュメントを読みやすくまとめる

まずは、膨大な公式ドキュメントの中から「今知りたいこと」だけを抽出してもらい、学習の全体像を素早く掴みます。

> **プロンプト例**
> ```
> 以下はLaravelの公式ドキュメントの一部です。 これを「多対多リレーションを実装できるように」分かりやすくまとめてください。
> 
> 出力してほしい内容：
> - 重要ポイント（10行以内）
> - 用語の説明（中間テーブル、命名規則など）
> - できること / できないこと（境界をはっきり）
> - よくある落とし穴（回避策つき）
> - 最小で動かすための手順（コードはまだ不要）
> 
> --- ここから ---
> {ここにLaravelのEloquent: RelationshipsのMany to Manyに関するドキュメントを貼り付ける}
> --- ここまで ---
> ```

### Step 2: 「なぜそうなる？」をはっきりさせる（理解を固める）

次に、自分の理解が正しいかを確認し、概念的な知識を確かなものにします。「なぜ中間テーブルが必要なのか？」といった根本的な疑問を解消することが目的です。

> **プロンプト例**
> ```
> Laravelの多対多リレーションについて、私の理解はこうです：
> 「contactsテーブルとtagsテーブルを直接つなぐのではなく、contact_tagという中間テーブルを作る。このテーブルにはcontact_idとtag_idだけを持たせて、どの問い合わせにどのタグが付いているかを管理する。テーブル名はアルファベット順の単数形でつなぐのがルール。」
> 
> お願い：
> 1) 正しいかチェックして、間違いがあれば「反例」で教えてください
> 2) 中間テーブルの仕組みを「入力→中で起きること→出力」で説明してください
> 3) どこまでがこの概念の範囲か（境界）を教えてください
> 4) よくある勘違いを3つ教えてください
> 5) 理解チェック問題を3問ください（答えつき）
> ```

### Step 3: 実装に落とす（指定フォーマット：手順→解説→例→解説）

概念を理解したら、いよいよ実装です。目的と前提知識を伝え、構造化されたフォーマットで段階的に実装方法を教えてもらいます。

> **プロンプト例**
> ```
> 目的は「お問い合わせ管理システムにタグ機能を追加するためのマイグレーション作成」です。
> 前提知識は「Laravelの基本的なマイグレーション（create_users_tableなど）は書ける」です。
> 
> 次の順番で出力してください：
> 
> A. 実装の手順・方針
>  - まず全体の方針（なぜそのやり方か）
>  - 手順を1〜Nで（各手順に「できたらOK」の条件も書く）
> 
> B. 関連技術の解説
>  - 必要な関連知識を3〜7個（foreignId, constrained, onDelete, 複合ユニークキーなど）
>  - 各項目は「一言で説明 → この実装で何に使う → 注意点」
> 
> C. 実装例
>  - まずtagsテーブルのマイグレーション
>  - 次にcontact_tagテーブルのマイグレーション
> 
> D. コードの解説
>  - 重要な部分だけ「何をしてるか」「なぜそう書くか」
>  - よくあるバグと対策
> 
> 追加で必要な情報があれば質問していいですが、最大3つまでにしてください。
> ```

### Step 4: 設計レビュー（指摘をもらう）

最後に、自分で書いたコード（この場合はマイグレーションの設計）をAIにレビューしてもらい、より良い設計にするためのフィードバックをもらいます。

> **プロンプト例**
> ```
> 以下のマイグレーション設計をレビューしてください。
> 
> - 目的：お問い合わせにタグを付ける機能
> - 要件：1つのお問い合わせに複数のタグを付けられる。タグは他の問い合わせとも共有される。
> - 制約：Laravel 10, MySQL 8.0
> - 設計案：
>   - `tags`テーブル (id, name, timestamps)
>   - `contact_tag`テーブル (id, contact_id, tag_id, timestamps)
> - 不安な点：問い合わせを消した時に、`contact_tag`のゴミデータが残らないか心配。同じ問い合わせに同じタグが2回登録できてしまうかもしれない。
> 
> 見てほしい観点：
> - 正しく動くか（抜け漏れ）
> - データの整合性
> - パフォーマンス
> - Laravelの規約に沿っているか
> 
> 出力：
> - 指摘を「重要度：高/中/低」で出す
> - 各指摘に「理由」「影響」「直し方」をつける
> - 最後に「この設計が失敗しやすい例」を3つ出す
> ```

## 7. まとめ ✨

このチャプターでは、タグ機能の土台となるデータベースの設計とマイグレーションを行いました。

- **多対多リレーション**: 一つの問い合わせが複数のタグを持ち、一つのタグが複数の問い合わせに紐づく関係性を学びました。
- **中間テーブル**: 多対多リレーションを実現するためには、2つのテーブルを繋ぐ`contact_tag`のような中間テーブルが不可欠であることを理解しました。
- **マイグレーションの規約とショートカット**: Laravelの規約に従った命名（`contact_tag`）や、`foreignId()->constrained()`のような便利な機能を使うことで、効率的かつ安全にマイグレーションを作成できることを体験しました。
- **データベース制約**: `unique`制約や外部キー制約、カスケード削除を設定することで、データの整合性と堅牢性を高めることの重要性を学びました。

これで、タグを保存するための器が用意できました。次のチャプターでは、このテーブルを操作するための「モデル」と、モデル間の「リレーション」を定義していきます。
