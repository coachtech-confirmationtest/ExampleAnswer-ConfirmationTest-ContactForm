# Chapter 6: 不正なデータを弾く門番 - FormRequestでバリデーションを実装する

## 🎯 このセクションで学ぶこと

このチャプターでは、アプリケーションを不正なデータから守るための「第二の門番」、**バリデーション**を実装します。具体的には、Laravelの**FormRequest**という機能を使って、コントローラーの処理が実行される前にユーザーからの入力値を検証し、ビジネスロジックと検証ロジックを綺麗に分離する方法を学びます。これにより、アプリケーションの堅牢性を高め、コードの可読性とメンテナンス性を向上させることができます。

## 1. はじめに 📖

### バリデーションとは？「入力値の健康診断」

前のチャプターで、認証という「第一の門番」を設置し、許可されたユーザーしか管理画面にアクセスできないようにしました。しかし、たとえ許可されたユーザーであっても、彼らからの入力が常に正しいとは限りません。例えば、必須であるはずのメールアドレスが空欄だったり、電話番号の欄に文字列が入力されたり、存在しないカテゴリーIDが送信されたりする可能性があります。このような不正なデータがデータベースに保存されてしまうと、予期せぬエラーやシステムの不整合を引き起こす原因となります。

そこで必要になるのが**バリデーション (Validation)**です。バリデーションとは、ユーザーから送信されたデータが、アプリケーションが期待する形式やルールに合致しているかをチェックする「入力値の健康診断」のようなものです。「この項目は必須です」「メールアドレスの形式で入力してください」「120文字以内で入力してください」といったルールを定義し、それに違反するデータは処理に進ませる前に弾きます。

このバリデーションロジックをコントローラー内に直接書くこともできますが、ルールが複雑になるにつれてコントローラーはどんどん肥大化し、本来の責務である「リクエストを適切な処理に振り分ける」という役割が見えにくくなってしまいます。この問題を解決するのが**FormRequest**です。FormRequestは、特定のリクエストに対するバリデーションルールを専門に扱うクラスです。これを使うことで、バリデーションという関心事をコントローラーから完全に分離し、コードをクリーンに保つことができるのです。

## 2. 要件の確認 📋

このアプリケーションで実装すべきバリデーションのルールを、機能ごとに整理します。

### お問い合わせ作成時 (`StoreContactRequest`)

| フィールド名 | バリデーションルール | 意味 |
| :--- | :--- | :--- |
| `first_name` | `required`, `string`, `max:255` | 必須。文字列型。最大255文字。 |
| `last_name` | `required`, `string`, `max:255` | 必須。文字列型。最大255文字。 |
| `gender` | `required`, `integer`, `in:1,2,3` | 必須。整数型。1, 2, 3のいずれかの値。 |
| `email` | `required`, `string`, `email`, `max:255` | 必須。文字列型。有効なメールアドレス形式。最大255文字。 |
| `tel` | `required`, `string`, `regex:/^[0-9]{10,11}$/` | 必須。文字列型。ハイフンなしの10桁または11桁の半角数字。 |
| `address` | `required`, `string`, `max:255` | 必須。文字列型。最大255文字。 |
| `building` | `nullable`, `string`, `max:255` | NULLを許容。文字列型。最大255文字。 |
| `category_id` | `required`, `exists:categories,id` | 必須。かつ、`categories`テーブルの`id`カラムに存在する値。 |
| `detail` | `required`, `string`, `max:120` | 必須。文字列型。最大120文字。 |

### 管理画面での検索時 (`IndexContactRequest`)

管理画面の検索機能では、入力は任意ですが、入力された場合のフォーマットは検証する必要があります。

| フィールド名 | バリデーションルール | 意味 |
| :--- | :--- | :--- |
| `keyword` | `nullable`, `string`, `max:255` | NULLを許容。文字列型。最大255文字。 |
| `gender` | `nullable`, `integer`, `in:0,1,2,3` | NULLを許容。整数型。0, 1, 2, 3のいずれかの値。 |
| `category_id` | `nullable`, `integer`, `exists:categories,id` | NULLを許容。整数型。`categories`テーブルの`id`カラムに存在する値。 |
| `date` | `nullable`, `date` | NULLを許容。有効な日付形式。 |

## 3. 先輩エンジニアの思考プロセス 💭

なぜバリデーションロジックをコントローラーから分離するのでしょうか？FormRequestを使いこなすための考え方を学びましょう。

### Point 1: クラスの「責務」は一つに絞る (単一責任の原則)

優れたソフトウェア設計の原則の一つに、**単一責任の原則 (Single Responsibility Principle, SRP)** があります。これは、「一つのクラスが持つべき責任は、ただ一つだけであるべきだ」という考え方です。コントローラーの本来の責任は、「ユーザーからのリクエストを受け取り、適切なビジネスロジック（モデルやサービスクラス）を呼び出し、結果をレスポンスとして返す」ことです。ここにバリデーションのロジックが大量に入り込むと、コントローラーは「リクエストの検証」と「ビジネスロジックの実行」という二つの責任を持つことになり、コードが複雑化・肥大化します。**FormRequest**は、この「リクエストの検証」という責任を専門に担うクラスです。責任を分離することで、コントローラーは本来の役割に集中でき、コード全体の見通しが良くなり、テストや修正が容易になります。これは、大規模なアプリケーションをクリーンに保つための非常に重要なテクニックです。

### Point 2: `authorize`メソッドは「認可」のための場所

FormRequestクラスには、`rules`メソッドの他に`authorize`というメソッドが必ず存在します。このメソッドは、バリデーションを実行する「前」に、リクエストを送信してきた認証済みユーザーが「その操作を実行する権限を持っているか」をチェック（**認可, Authorization**）するために使われます。例えば、「投稿の編集リクエストは、その投稿の作成者本人からでなければならない」といったルールをここに記述します。権限チェックが不要な場合は、単純に`return true;`としておけば、誰からのリクエストも許可されます。初心者はこのメソッドを単なるおまじないと捉えがちですが、`authorize`（認可）と`rules`（検証）という、二つの異なるセキュリティチェックの段階が用意されていることを理解しておくことが重要です。

### Point 3: バリデーションルールは「組み合わせ」で表現する

Laravelが提供するバリデーションルールは非常に豊富です。`required`（必須）、`string`（文字列）、`max`（最大値）といった基本的なものから、`exists`（データベースのテーブルに存在するか）、`unique`（テーブル内で一意か）、`regex`（正規表現に一致するか）といった高度なものまで様々です。これらのルールは、配列の要素として複数指定することができます。例えば、`["required", "email", "max:255"]`と書けば、「必須」かつ「メールアドレス形式」かつ「最大255文字」という3つのルールを同時に適用できます。これらのルールを組み合わせることで、ほとんどの検証要件を宣言的に、かつ簡潔に表現することができます。

### Point 4: エラーメッセージは「ユーザーへの指示」と心得る

バリデーションが失敗したときに表示されるエラーメッセージは、単に「エラーが起きた」ことを伝えるだけのものではありません。ユーザーに「次に何をすべきか」を明確に伝えるための、重要なコミュニケーション手段です。Laravelのデフォルトのエラーメッセージは英語ですが、これを日本語化したり、より分かりやすい表現にカスタマイズしたりすることが推奨されます。例えば、「The email field is required.」よりも「メールアドレスは必須項目です。」の方が親切です。さらに、「The tel must be a number.」よりも「電話番号はハイフンなしの10〜11桁で入力してください。」の方が、ユーザーが取るべき具体的なアクションを示しています。FormRequestクラス内に`messages`メソッドを定義することで、ルールごとにエラーメッセージを簡単にカスタマイズできます。優れたUX（ユーザー体験）は、こういった細やかな配慮の積み重ねによって生まれます。

## 4. 実装 🚀

それでは、`StoreContactRequest`と`IndexContactRequest`という2つのFormRequestクラスを作成していきましょう。

### 4.1. FormRequestファイルの作成

以下の`sail artisan make:request`コマンドで、2つのFormRequestクラスのファイルを生成します。

```bash
# お問い合わせ作成用のFormRequestを作成
sail artisan make:request StoreContactRequest

# 管理画面検索用のFormRequestを作成
sail artisan make:request IndexContactRequest
```

このコマンドを実行すると、`app/Http/Requests/`ディレクトリに`StoreContactRequest.php`と`IndexContactRequest.php`が作成されます。

### 4.2. `StoreContactRequest.php`の編集

作成された`app/Http/Requests/StoreContactRequest.php`を開き、`authorize`メソッド、`rules`メソッド、そして`messages`メソッドを以下のように編集します。

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreContactRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'first_name' => ['required', 'string', 'max:255'],
            'last_name' => ['required', 'string', 'max:255'],
            'gender' => ['required', 'integer', 'in:1,2,3'],
            'email' => ['required', 'string', 'email', 'max:255'],
            'tel' => ['required', 'string', 'regex:/^[0-9]{10,11}$/'],
            'address' => ['required', 'string', 'max:255'],
            'building' => ['nullable', 'string', 'max:255'],
            'category_id' => ['required', 'exists:categories,id'],
            'detail' => ['required', 'string', 'max:120'],
        ];
    }

    public function messages(): array
    {
        return [
            'first_name.required' => '姓を入力してください',
            'last_name.required' => '名を入力してください',
            'gender.required' => '性別を選択してください',
            'email.required' => 'メールアドレスを入力してください',
            'email.email' => 'メールアドレスの形式で入力してください',
            'tel.required' => '電話番号を入力してください',
            'tel.regex' => '電話番号はハイフンなしの10〜11桁で入力してください',
            'address.required' => '住所を入力してください',
            'category_id.required' => 'お問い合わせの種類を選択してください',
            'detail.required' => 'お問い合わせ内容を入力してください',
            'detail.max' => 'お問い合わせ内容は120文字以内で入力してください',
        ];
    }
}
```

### 4.3. `IndexContactRequest.php`の編集

次に、`app/Http/Requests/IndexContactRequest.php`を開き、同様に編集します。こちらは検索機能なので、多くの項目が任意入力（`nullable`）になります。

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class IndexContactRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'keyword' => ['nullable', 'string', 'max:255'],
            'gender' => ['nullable', 'integer', 'in:0,1,2,3'],
            'category_id' => ['nullable', 'integer', 'exists:categories,id'],
            'date' => ['nullable', 'date'],
        ];
    }

    public function messages(): array
    {
        return [
            'keyword.max' => 'キーワードは255文字以内で入力してください',
            'gender.in' => '性別の値が不正です',
            'category_id.exists' => '選択されたカテゴリーが存在しません',
            'date.date' => '日付の形式が正しくありません',
        ];
    }
}
```

### 4.4. コントローラーでの利用

作成したFormRequestをコントローラーで利用するには、アクションメソッドの引数の型を、`Illuminate\Http\Request`から作成したFormRequestクラスに変更するだけです。

```php
// 例: AdminController.php

// use Illuminate\Http\Request; // こちらは不要になる
use App\Http\Requests\IndexContactRequest; // 作成したFormRequestをuseする

class AdminController extends Controller
{
    // 引数の型をIndexContactRequestに変更
    public function index(IndexContactRequest $request)
    {
        // このメソッドが実行される前に、IndexContactRequestのバリデーションが自動的に実行される
        // バリデーションが失敗した場合、この処理は実行されずに前のページにリダイレクトされる

        // バリデーション済みのデータを取得
        $validated = $request->validated();

        // ... 検索処理など
    }
}
```

Laravelのサービスコンテナが、ルートとコントローラーメソッドを結合する際に、引数の型がFormRequestであることを検知し、自動的にバリデーションを実行してくれます。もしバリデーションが失敗すると、Laravelは自動的にユーザーを直前のページにリダイレクトさせ、エラーメッセージをセッションにフラッシュします。成功した場合のみ、コントローラーの処理が続行されます。この仕組みにより、コントローラーにはバリデーションのロジックが一切現れず、非常にクリーンな状態を保つことができます。

## 5. コードの詳細解説 🔍

### `StoreContactRequest.php` / `IndexContactRequest.php` の解説

- **`class StoreContactRequest extends FormRequest`**
  作成したクラスが、Laravelの基本的なリクエスト機能に加えて、バリデーション機能を持つ`FormRequest`クラスを継承していることを示します。

- **`public function authorize(): bool`**
  このリクエストが認可されるべきかどうかを判定します。`false`を返すと、ユーザーは403 Forbiddenエラーページにリダイレクトされます。今回は単純に`true`を返していますが、実際のアプリケーションでは`$this->user()->can("update", $post)`のように、認証済みユーザーが特定の操作を行う権限を持っているかをチェックするロジックを記述します。

- **`public function rules(): array`**
  このリクエストに対するバリデーションルールを配列で定義します。キーがフォームの入力フィールドの`name`属性、値が適用するルールです。

- **`regex:/^[0-9]{10,11}$/`**
  `regex`ルールは、入力値が指定された**正規表現**にマッチするかを検証します。ここでは「`^`（先頭）から`$`（末尾）までが、`[0-9]`（半角数字）の`{10,11}`（10回から11回）の繰り返しである」という意味になり、ハイフンなしの10桁または11桁の電話番号を厳密に検証できます。

- **`exists:categories,id`**
  `exists`ルールはデータベースに関連する強力なルールです。`exists:テーブル名,カラム名`の形式で記述し、入力された値が指定したテーブルの指定したカラムに存在するかどうかをチェックします。これにより、存在しないカテゴリーIDが送信されてくるのを防ぎ、データベースの整合性を保ちます。

- **`public function messages(): array`**
  バリデーションが失敗した際に表示されるエラーメッセージをカスタマイズします。キーは`フィールド名.ルール名`の形式で指定し、値に表示したいメッセージを記述します。これにより、ユーザーにとってより親切で分かりやすいエラー表示を実現できます。

## 6. How to: この実装にたどり着くための調べ方 🗺️

新しい技術を学ぶとき、やみくもに検索するのではなく、戦略的にAIを活用することで、より早く、より深く理解することができます。ここでは、エンジニアが新しい技術を学習する際の4つのステップと、それぞれのステップで使えるAIへの質問（プロンプト）の例を紹介します。

### Step 1: 公式ドキュメントを読みやすくまとめる

**目的**: まずは公式ドキュメントをAIに要約させ、技術の全体像を素早く掴みます。

**プロンプト例**: 
```
以下はLaravelのバリデーションに関する公式ドキュメントの一部です。 これを「実装できるように」分かりやすくまとめてください。

出力してほしい内容：
- 重要ポイント（10行以内）
- 用語の説明（FormRequest, Ruleオブジェクトなど）
- できること / できないこと（境界をはっきり）
- よくある落とし穴（コントローラーが肥大化する問題など）
- 最小で動かすための手順（コードはまだ不要）

--- ここから ---
{ここにLaravelのバリデーションに関する公式ドキュメントを貼り付ける}
--- ここまで ---
```

**ポイント**: このステップでは、詳細なコードよりも「何ができて、何が重要なのか」という地図を手に入れることが目的です。AIに情報を整理・要約させることで、学習の全体像を把握し、次のステップに進みやすくなります。

### Step 2: 「なぜそうなる？」をはっきりさせる（理解を固める）

**目的**: 表面的な理解で終わらせず、「なぜその技術が必要なのか」「どのような仕組みで動いているのか」を深く理解します。

**プロンプト例**: 
```
LaravelのFormRequestについて、私の理解はこうです：
「コントローラーに書くべきバリデーションロジックを、別の専用クラスに分離するための仕組み。これによってコントローラーがスッキリする。」

お願い：
1) この理解が正しいかチェックして、間違いがあれば「具体例」で教えてください。
2) FormRequestの仕組みを「HTTPリクエスト→中で起きること→コントローラーのメソッド実行」の流れで説明してください。
3) どこまでがFormRequestの範囲か（境界）を教えてください（例: 認可は範囲内？）。
4) FormRequestでよくある勘違いを3つ教えてください。
5) 理解チェック問題を3問ください（答えつき）。
```

**ポイント**: 自分の言葉で理解を説明し、それをAIに検証してもらうことで、知識の定着度が一気に上がります。「入力→処理→出力」の形式で仕組みを尋ねることで、技術のブラックボックスをなくすことができます。

### Step 3: 実装に落とす（指定フォーマット：手順→解説→例→解説）

**目的**: 概念の理解を、実際の手を動かす「実装」に繋げます。AIに手順書とコード例を作成させ、それに沿って実装を進めます。

**プロンプト例**: 
```
目的は「お問い合わせフォームの入力内容を検証するFormRequestの作成」です。
前提知識は「Laravelのコントローラーとルーティングは理解している」です。

次の順番で出力してください：

A. 実装の手順・方針
- まず全体の方針（なぜコントローラーでなくFormRequestを使うか）
- 手順を1〜Nで（各手順に「できたらOK」の条件も書く）

B. 関連技術の解説
- 必要な関連知識を3〜5個（例: `make:request`コマンド, `rules`メソッド, `messages`メソッド, `authorize`メソッド）
- 各項目は「一言で説明 → この実装で何に使う → 注意点」

C. 実装例
- まず最小で動く例（必須項目だけをチェック）
- 次に実務向けの拡張例（正規表現、DB連携、カスタムメッセージ）

D. コードの解説
- 重要な部分だけ「何をしてるか」「なぜそう書くか」
- よくあるバグと対策

追加で必要な情報があれば質問していいですが、最大3つまでにしてください。
```

**ポイント**: 出力形式を細かく指定することで、AIから自分が欲しい情報を、欲しい順番で引き出すことができます。「最小の例」から始めて「実務向けの例」にステップアップすることで、無理なく実装スキルを習得できます。

### Step 4: 設計レビュー（指摘をもらう）

**目的**: 自分で書いたコードや設計が「これで本当に良いのか」をAIにレビューしてもらい、より良い設計・実装を目指します。

**プロンプト例**: 
```
以下のFormRequestの設計をレビューしてください。

- 目的：お問い合わせフォームの入力値検証
- 要件：
  - 電話番号はハイフンなしの10桁または11桁
  - カテゴリーIDは`categories`テーブルに実際に存在するIDであること
- 制約：Laravel 10, PHP 8.2
- 設計案（`rules`メソッドの中身）：
{
    'tel' => ['required', 'numeric', 'digits_between:10,11'],
    'category_id' => ['required', 'integer', 'exists:categories,id'],
}
- 不安な点：
  - `numeric`と`digits_between`で電話番号の要件を本当に満たせるか？
  - `exists`ルールはパフォーマンスに影響しないか？

見てほしい観点：
- 正しく動くか（要件の抜け漏れ）
- 変更しやすいか（ルールが追加された場合）
- セキュリティ（不正な値を許可してしまう可能性）

出力：
- 指摘を「重要度：高/中/低」で出す
- 各指摘に「理由」「影響」「直し方」をつける
- 最後に「この設計が失敗しやすい例」を3つ出す
```

**ポイント**: 自分の「不安な点」を具体的に書くことで、AIはより的確なアドバイスをくれます。レビューの観点を指定することで、多角的な視点からフィードバックを得ることができ、コードの品質を向上させることができます。

## 7. 提供されているBladeファイルの確認 📄

バリデーションが失敗したとき、エラーメッセージはどのように表示されるのでしょうか。提供されているBladeファイルを見てみましょう。

`resources/views/contact/_form.blade.php`（お問い合わせフォームの部品）の中に、以下のような記述があります。

```blade
@error("first_name")
    <p class="text-red-500 text-xs mt-1">{{ $message }}</p>
@enderror
```

- **`@error("first_name")`**: `first_name`フィールドにバリデーションエラーが存在する場合にのみ、このブロック内を表示するというBladeのディレクティブです。
- **`{{ $message }}`**: Laravelが自動的に用意してくれる変数で、そのフィールドに対する具体的なエラーメッセージ（`messages`メソッドでカスタマイズした場合はそのメッセージ）が格納されています。

このように、Bladeファイル側では`@error`ディレクティブを使うだけで、FormRequestから返されたエラーメッセージを簡単に表示することができます。FormRequestとBladeがうまく連携することで、エラーハンドリングの仕組みが完成します。

## 8. まとめ ✨

このチャプターでは、FormRequestを使って、アプリケーションの堅牢性を高めるバリデーションを実装しました。

- **責務の分離**: バリデーションロジックをFormRequestクラスに分離することで、コントローラーをクリーンに保つことの重要性を学びました。
- **FormRequestの実装**: `make:request`コマンドでクラスを作成し、`authorize`メソッドと`rules`メソッドを定義し、コントローラーの引数で型指定するという一連の流れを実践しました。
- **エラーメッセージのカスタマイズ**: `messages`メソッドを定義することで、ユーザーにとって分かりやすいエラーメッセージを表示する方法を学びました。
- **豊富なバリデーションルール**: `regex`や`exists`など、Laravelが提供する多様なルールを組み合わせて、複雑な要件に対応できることを理解しました。

これで、アプリケーションは不正な形式のデータを処理の入り口で弾くことができるようになりました。しかし、データベースから取得したデータをそのままフロントエンドに返すと、不要な情報まで公開してしまったり、フォーマットがバラバラだったりする問題が起こり得ます。次のチャプターでは、APIのレスポンスを美しく整形するための「化粧箱」、**APIリソース**について学びます。
