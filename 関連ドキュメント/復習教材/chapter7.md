# Chapter 7: APIレスポンスの化粧箱 - APIリソースでJSONを整形する

## 🎯 このセクションで学ぶこと

このチャプターでは、Eloquentモデルから生成されるJSONレスポンスを、柔軟かつ安全に整形するための「変換レイヤー」、**APIリソース**について学びます。APIリソースを使うことで、データベースの構造を外部に直接公開することなく、APIの利用者が本当に必要とするデータだけを、一貫性のある美しいフォーマットで提供する方法を習得します。これにより、APIの保守性とセキュリティが格段に向上します。

## 1. はじめに 📖

### APIリソースとは？モデルとJSONの「通訳兼スタイリスト」

これまでのチャプターで、データベースからデータを取得するためのモデルを定義しました。コントローラーでEloquentモデルを取得し、そのまま`return`すると、Laravelは自動的にそのモデルをJSON形式に変換してレスポンスとして返してくれます。これは非常に便利ですが、いくつかの問題点も抱えています。

1.  **不要なデータまで公開してしまう**: モデルのすべての属性（`created_at`や`updated_at`など）がそのままJSONに含まれてしまい、APIの利用者にとってはノイズになります。最悪の場合、パスワードのハッシュ値のような、決して外部に漏れてはならない情報まで公開してしまう危険性があります。
2.  **データ形式を加工できない**: データベースには効率を重視して`1`や`2`のような数値で保存されているデータを、APIでは「男性」「女性」のような人間が読みやすい文字列として返したい場合があります。モデルを直接返却する方法では、このようなデータ変換が困難です。
3.  **APIの構造がデータベース構造に縛られる**: データベースのカラム名を変更すると、それが即座にAPIのレスポンスのキー名に影響してしまいます。APIの利用者（フロントエンドなど）は、その変更に追随してコードを修正する必要があり、密結合な関係になってしまいます。

これらの問題をエレガントに解決するのが**APIリソース**です。APIリソースは、Eloquentモデルと最終的なJSONレスポンスの間に位置する「変換レイヤー」です。モデルを「原材料」として受け取り、どのデータを、どのようなキー名で、どのような形式でJSONに含めるかを定義する「通訳兼スタイリスト」のような役割を果たします。これにより、データベースの内部構造を隠蔽し、APIとして公開したい情報だけを整形して返すことができるのです。

## 2. 要件の確認 📋

このアプリケーションのAPIが返すべき、理想的なJSONの構造を定義します。

### `categories` APIのレスポンス

カテゴリー情報を取得するAPI (`/api/categories`) は、以下のようなシンプルな構造であるべきです。

```json
{
    "data": [
        {
            "id": 1,
            "content": "商品のお届けについて"
        },
        {
            "id": 2,
            "content": "商品の交換について"
        }
    ]
}
```

### `contacts` APIのレスポンス

お問い合わせ情報を取得するAPI (`/api/contacts`) は、モデルの属性をそのまま返却しつつ、関連するカテゴリーの情報もネストされたオブジェクトとして含めるべきです。

```json
{
    "data": [
        {
            "id": 1,
            "first_name": "太郎",
            "last_name": "山田",
            "gender": 1,
            "email": "test@example.com",
            "tel": "09012345678",
            "address": "東京都渋谷区千駄ヶ谷5-27-5",
            "building": "リンクススクエア新宿",
            "detail": "商品の詳細について知りたいです。",
            "category": {
                "id": 1,
                "content": "商品のお届けについて"
            }
        }
    ],
    "links": { ... }, // ページネーション情報
    "meta": { ... }   // ページネーション情報
}
```

**整形ポイント:**
- すべてのデータは`data`キーでラップする。
- モデルが持つ属性（`id`, `first_name`など）をそのままJSONのキーとして使用する。
- 関連するカテゴリー情報を`category`キーにネストして含める。

## 3. 先輩エンジニアの思考プロセス 💭

なぜ一手間かけてまでAPIリソースを使うのでしょうか？その背景にある、堅牢なAPIを設計するための思想を学びましょう。

### Point 1: APIは「公開用のインターフェース」。内部構造を絶対に漏らさない

APIは、アプリケーションの機能を外部に提供するための「公式な窓口（インターフェース）」です。この窓口から、アプリケーションの内部構造（データベースのテーブル名やカラム名、モデルのプロパティなど）が見えてしまうのは、非常に危険で、かつ行儀の悪い設計です。例えば、ユーザーモデルに`password`や`remember_token`といった機密情報が含まれている場合、それをそのままJSONとして返してしまうと、重大なセキュリティインシデントに繋がります。APIリソースを使うことで、レスポンスに含める属性を「ホワイトリスト形式」で明示的に指定します。これにより、意図しない情報が外部に漏れることを確実に防ぐことができます。これは、安全なAPIを構築するための絶対的な原則です。

### Point 2: APIの「契約」は、一度決めたら軽々しく変えない

APIを一度公開すると、そのAPIを利用するクライアント（フロントエンドのJavaScriptやスマートフォンアプリなど）が作られます。クライアントは、APIが返すJSONの構造（キーの名前やデータの型）を「契約」として信頼し、それを前提に実装されています。もしサーバーサイドの都合で、`user_name`というキーを`name`に勝手に変更してしまうと、そのAPIを利用しているすべてのクライアントが動かなくなり、大規模な障害を引き起こします。APIリソース層を設けることで、たとえデータベースのカラム名を`user_name`から`full_name`に変更したとしても、APIリソース側で`"name" => $this->full_name`のようにマッピングを調整すれば、APIのレスポンス構造は`"name"`のまま維持できます。このように、APIリソースは、内部実装の変更からAPIの「契約」を守るための重要な緩衝材（バッファ）として機能します。

### Point 3: レスポンスの構造に一貫性を持たせる

優れたAPIは、どのエンドポイントを叩いても、返ってくるJSONの構造に一貫性があります。例えば、すべてのレスポンスが`data`というキーで実際のデータをラップしている、ページネーションの情報は常に`links`と`meta`キーに含まれている、などです。APIリソースを使うと、この一貫性を簡単に実現できます。`Resource::collection()`を使うと、自動的に`data`キーでラップされたJSONが生成されます。さらに、独自の`BaseResource`クラスを作成して、すべてのリソースクラスに共通の処理（例えば、常に`status`キーを含めるなど）を継承させることも可能です。一貫性のあるAPIは、利用者にとって予測可能で、非常に使いやすいものになります。

### Point 4: 関連データは「必要なときだけ」含める (Eager Loadingとの連携)

APIリソースでは、`$this->whenLoaded("category")`のように、リレーションが「事前に読み込まれている（Eager Loadされている）場合のみ」レスポンスに含める、という条件分岐ができます。これは非常に重要です。もしこのチェックがないと、リソースが変換されるたびに、関連データを取得するための追加のデータベースクエリ（N+1問題）が発生し、深刻なパフォーマンス低下を引き起こす可能性があります。コントローラー側で`Contact::with("category")->get()`のように明示的に`with`を使ってEager Loadingを行い、リソース側では`whenLoaded`でその存在をチェックする。この連携プレイによって、初めてパフォーマンスと柔軟性を両立したAPIレスポンスを構築できるのです。

## 4. 実装 🚀

それでは、`CategoryResource`と`ContactResource`を作成し、APIのレスポンスを整形していきましょう。

### 4.1. APIリソースファイルの作成

以下の`sail artisan make:resource`コマンドで、2つのAPIリソースクラスのファイルを生成します。

```bash
# Category用のAPIリソースを作成
sail artisan make:resource CategoryResource

# Contact用のAPIリソースを作成
sail artisan make:resource ContactResource
```

このコマンドを実行すると、`app/Http/Resources/`ディレクトリに`CategoryResource.php`と`ContactResource.php`が作成されます。

### 4.2. `CategoryResource.php`の編集

作成された`app/Http/Resources/CategoryResource.php`を開き、`toArray`メソッドを以下のように編集します。カテゴリーAPIはシンプルに`id`と`content`だけを返します。

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class CategoryResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            "id" => $this->id,
            "content" => $this->content,
        ];
    }
}
```

### 4.3. `ContactResource.php`の編集

次に、`app/Http/Resources/ContactResource.php`を開き、モデルの属性をそのまま返すように記述します。

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ContactResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'category' => new CategoryResource($this->whenLoaded('category')),
            'first_name' => $this->first_name,
            'last_name' => $this->last_name,
            'gender' => $this->gender,
            'email' => $this->email,
            'tel' => $this->tel,
            'address' => $this->address,
            'building' => $this->building,
            'detail' => $this->detail,
        ];
    }
}
```

### 4.4. コントローラーでの利用

作成したAPIリソースをコントローラーで使うのは非常に簡単です。モデルやモデルのコレクションを、リソースクラスのコンストラクタに渡して`return`するだけです。

#### 単一のリソースを返す場合

```php
// Api/ContactController.php の show メソッドなど

use App\Http\Resources\ContactResource;
use App\Models\Contact;

public function show(Contact $contact)
{
    // 関連データを事前に読み込む
    $contact->load("category");
    return new ContactResource($contact);
}
```

#### リソースのコレクションを返す場合

```php
// Api/ContactController.php の index メソッドなど

use App\Http\Resources\ContactResource;
use App\Models\Contact;

public function index()
{
    // 関連データを事前に読み込み、ページネーションを適用
    $contacts = Contact::with("category")->paginate(10);
    return ContactResource::collection($contacts);
}
```

## 5. コードの詳細解説 🔍

### `app/Http/Resources/CategoryResource.php` と `app/Http/Resources/ContactResource.php`

- **`class ... extends JsonResource`**
  - **何をしているか**: 作成したクラスが、JSONレスポンスの整形機能を持つ`JsonResource`クラスを継承していることを示します。
  - **なぜそう書くか**: `JsonResource`が持つ便利な機能（`collection`メソッドや`whenLoaded`など）を利用するためです。

- **`public function toArray(Request $request): array`**
  - **何をしているか**: このリソースがJSONに変換される際に、どのような配列構造になるべきかを定義する中心的なメソッドです。戻り値の配列が、そのままJSONの構造になります。
  - **なぜそう書くか**: APIとして公開したいデータ構造を、このメソッド内で自由にコントロールするためです。データベースの構造とAPIのレスポンス構造を分離する要となります。

- **`'id' => $this->id`**
  - **何をしているか**: `$this`は、リソースに渡されたモデルインスタンス（この場合は`Contact`モデルや`Category`モデル）を指します。`$this->id`とすることで、モデルの`id`プロパティの値を取得し、JSONの`id`キーに割り当てています。
  - **なぜそう書くか**: モデルが持つどのプロパティを、JSONのどのキー名で公開するかを明示的に定義するためです。これにより、不要な情報を排除し、キー名を分かりやすく変更できます。

- **`'category' => new CategoryResource($this->whenLoaded('category'))`**
  - **何をしているか**: ここがリレーションを扱う上で最も重要な部分です。`Contact`モデルに紐づく`category`リレーションを、`CategoryResource`を使って整形し、JSONに含めています。
  - **なぜそう書くか**:
    - **`$this->whenLoaded('category')`**: `Contact`モデルの`category`リレーションが、コントローラー側で`with()`や`load()`を使って事前に読み込まれている（Eager Loadingされている）場合にのみ、そのリレーションのモデル（`Category`モデル）を返します。もし読み込まれていなければ、この要素は最終的なJSONから完全に除外され、不要なデータベースクエリ（N+1問題）の発生を防ぎます。パフォーマンスを維持するための必須のテクニックです。
    - **`new CategoryResource(...)`**: Eager Loadingされた`Category`モデルを、さらに`CategoryResource`を使って整形しています。これにより、リソースのネスト（入れ子）構造が実現され、レスポンスがより構造化され、分かりやすくなります。

### `app/Http/Controllers/Api/ContactController.php`

- **`return new ContactResource($contact);`**
  - **何をしているか**: 単一のモデルインスタンスを`ContactResource`で変換して返却しています。
  - **なぜそう書くか**: 1件のデータを取得する`show`メソッドなどで使用します。この場合、レスポンスは`data`キーでラップされません。

- **`return ContactResource::collection($contacts);`**
  - **何をしているか**: モデルのコレクション（特にページネーションされた結果）を`ContactResource`で変換して返却しています。
  - **なぜそう書くか**: 一覧データを取得する`index`メソッドなどで使用します。`collection`静的メソッドを使うことで、自動的にレスポンス全体が`data`キーでラップされ、ページネーション情報が`links`と`meta`キーに付与されます。これにより、APIレスポンスの構造に一貫性を持たせることができます。

## 6. How to: この実装にたどり着くための調べ方 🗺️

実務でAPIリソースを使いこなすための、AIアシスタントを活用した4ステップの学習方法を紹介します。

### Step 1: 公式ドキュメントを読みやすくまとめる

まずは、Laravelの公式ドキュメントをAIに要約してもらい、全体像を素早く掴みます。

> **プロンプト例**
> 以下はLaravelの公式ドキュメントの一部です。 これを「実装できるように」分かりやすくまとめてください。
>
> 出力してほしい内容：
> - 重要ポイント（10行以内）
> - 用語の説明（重要なものだけ）
> - できること / できないこと（境界をはっきり）
> - よくある落とし穴（回避策つき）
> - 最小で動かすための手順（コードはまだ不要）
>
> --- ここから ---
> {ここにLaravel公式ドキュメントの「Eloquent: APIリソース」のセクションを貼り付ける}
> --- ここまで ---

**🤖 このプロンプトのポイント**
- **目的の明確化**: 「実装できるように」と目的を伝えることで、AIは単なる要約ではなく、実践的な観点から情報を整理してくれます。
- **構造化された出力形式**: 出力形式を指定することで、自分が欲しい情報を漏れなく、かつ比較しやすい形で得ることができます。
- **情報源の限定**: `{---}`で囲んで情報源を限定することで、AIが不確かな情報源から回答を生成するのを防ぎ、公式ドキュメントに基づいた正確な回答を引き出せます。

### Step 2: 「なぜそうなる？」をはっきりさせる（理解を固める）

次に、APIリソースの核心的な概念について、自分の理解が正しいかを確認し、知識を固めます。

> **プロンプト例**
> LaravelのAPIリソースについて、私の理解はこうです：
> 「APIリソースは、モデルとコントローラーの間に挟まる層で、モデルのどのデータをJSONとして返すかを定義するもの。これによって、`created_at`のような不要なカラムを隠したり、リレーションを綺麗にネストさせたりできる。」
>
> お願い：
> 1) 正しいかチェックして、間違いがあれば「反例」で教えてください
> 2) `whenLoaded`の仕組みを「入力→中で起きること→出力」で説明してください
> 3) APIリソースの責務はどこまでか（境界）を教えてください（例：データの取得やバリデーションは責務外？）
> 4) よくある勘違いを3つ教えてください
> 5) 理解チェック問題を3問ください（答えつき）

**🤖 このプロンプトのポイント**
- **自分の理解を提示**: 自分の現在の理解を先に示すことで、AIはどこが間違っているのか、どこが不足しているのかを的確に指摘できます。
- **具体的な質問**: 「`whenLoaded`の仕組み」「責務の境界」など、ピンポイントで具体的な質問をすることで、曖昧さを排除し、深い理解につながる回答を得られます。
- **理解度チェック**: 「理解チェック問題」を要求することで、自分が本当に知識を消化できているかを確認し、記憶の定着を促します。

### Step 3: 実装に落とす（指定フォーマット：手順→解説→例→解説）

概念を理解したら、具体的な実装方法を学びます。構造化されたフォーマットで出力させることで、体系的に知識を吸収できます。

> **プロンプト例**
> 目的は、Laravelでお問い合わせ（Contact）の一覧を取得するAPIを作り、レスポンスをAPIリソースで整形することです。
> 制約は、N+1問題を必ず避けることです。
> 前提知識は、Eloquentモデルとリレーションの基本は理解しています。
>
> 次の順番で出力してください：
>
> A. 実装の手順・方針
>  - まず全体の方針（なぜそのやり方か）
>  - 手順を1〜Nで（各手順に「できたらOK」の条件も書く）
>
> B. 関連技術の解説
>  - 必要な関連知識を3〜7個（例: `JsonResource`, `ResourceCollection`, `whenLoaded`）
>  - 各項目は「一言で説明 → この実装で何に使う → 注意点」
>
> C. 実装例
>  - まず最小で動く例（コントローラーとリソースクラス）
>  - 次に実務向けの拡張例（ページネーションを適用）
>
> D. コードの解説
>  - 重要な部分だけ「何をしてるか」「なぜそう書くか」
>  - よくあるバグと対策

**🤖 このプロンプトのポイント**
- **PDR (Purpose, Definition, Role)**: 「目的」「制約」「前提知識」を最初に伝えることで、AIにコンテキストを正確に理解させ、的外れな回答を防ぎます。
- **構造化フォーマットの指定**: 「A. 手順 → B. 解説 → C. 実装例 → D. コード解説」という流れを指定することで、知識をインプット（B, D）とアウトプット（A, C）に分けながら、段階的に学習を進めることができます。
- **具体例の要求**: 「最小で動く例」と「実務向けの拡張例」の両方を要求することで、基本から応用までをスムーズに繋げて学ぶことができます。

### Step 4: 設計レビュー（指摘をもらう）

最後に、自分で書いたコードや設計案をAIにレビューしてもらい、より良い設計への改善点を探ります。

> **プロンプト例**
> 以下のAPIリソースの設計をレビューしてください。
>
> - 目的：お問い合わせ情報を返すAPIのレスポンス整形
> - 設計案：
> ```php
> // ContactResource.php
> public function toArray(Request $request): array
> {
>     return [
>         'contact_id' => $this->id,
>         'full_name' => $this->last_name . ' ' . $this->first_name,
>         'contact_category' => new CategoryResource($this->category),
>         'received_at' => $this->created_at->format('Y-m-d H:i'),
>     ];
> }
> ```
> - 不安な点：
>   - `contact_category`で`whenLoaded`を使い忘れているが、問題ないか？
>   - キー名を`contact_id`のようにプレフィックス付きにしているが、これは良い習慣か？
>
> 見てほしい観点：
> - パフォーマンス（N+1問題）
> - 保守性（キー名の命名規則）
> - 一貫性（他のAPIとのフォーマットのズレ）
>
> 出力：
> - 指摘を「重要度：高/中/低」で出す
> - 各指摘に「理由」「影響」「直し方」をつける
> - 最後に「この設計が失敗しやすい例」を3つ出す

**🤖 このプロンプトのポイント**
- **レビュー依頼の明確化**: 「設計案」と「不安な点」を具体的に示すことで、AIは何に焦点を当ててレビューすればよいかを正確に理解します。
- **観点の指定**: 「パフォーマンス」「保守性」など、見てほしい観点を指定することで、多角的な視点からのフィードバックを得られます。
- **構造化された指摘**: 指摘を「重要度」「理由」「影響」「直し方」のセットで要求することで、なぜそれが問題で、どう直せばよいのかを具体的に理解でき、次のアクションに繋がりやすくなります。

## 7. まとめ ✨

このチャプターでは、APIリソースを使って、APIのレスポンスを安全かつ柔軟に整形する方法を学びました。

- **責務の分離**: レスポンスの整形という責務をAPIリソースクラスに分離することで、コントローラーをクリーンに保ち、データベース構造を外部から隠蔽しました。
- **APIリソースの実装**: `make:resource`コマンドでクラスを作成し、`toArray`メソッドでレスポンスの構造を定義しました。
- **コレクションの扱い**: `Resource::collection()`を使うことで、ページネーションされたデータも一貫性のあるフォーマットで返せることを学びました。
- **N+1問題の回避**: `whenLoaded`メソッドを使い、Eager Loadingされたリレーションのみをレスポンスに含めることで、パフォーマンスを維持する方法を習得しました。

これで、アプリケーションの「入力（FormRequest）」と「出力（APIリソース）」の両方に、堅牢な門番を設置することができました。次のチャプターでは、これまでに作成した部品（モデル、FormRequest、APIリソース）を実際に組み合わせてビジネスロジックを組み立てる、アプリケーションの心臓部である**コントローラー**の実装に焦点を当てていきます。
