# Chapter 2: アプリケーションの骨格作り - マイグレーションでデータベースを設計する

## 🎯 このセクションで学ぶこと

このチャプターでは、アプリケーションのデータを保存するための「骨格」となるデータベースのテーブルを作成します。具体的には、Laravelの**マイグレーション**という強力な機能を使い、PHPのコードでデータベースの構造を定義し、バージョン管理する方法を学びます。これにより、誰が作業しても同じデータベース構造を正確に再現できるようになります。

## 1. はじめに 📖

### マイグレーションとは？データベースの「設計図」

環境構築というキッチンの準備が終わったので、次はいよいよ料理の土台となる「食材の置き場所」、つまりデータベースの準備をします。**マイグレーション**は、データベースのテーブル構造をPHPコードで記述し、管理するための仕組みです。これを「データベースの設計図」と考えると分かりやすいでしょう。

家を建てるとき、口頭の指示だけで柱を立てたり壁を作ったりすると、人によってバラバラな家ができてしまいます。しかし、全員が同じ「設計図」を共有していれば、誰が建てても同じ家が完成します。マイグレーションもこれと同じで、SQLを直接実行するのではなく、PHPコードという共通の設計図を使うことで、チームの誰が実行しても、あるいは将来の自分が実行しても、全く同じ構造のデータベースを確実に再現できるのです。さらに、この設計図はGitでバージョン管理できるため、「いつ」「誰が」「どのような変更を加えたか」を追跡することも可能になります。

## 2. 要件の確認 📋

Chapter 0で確認した要件に基づき、今回作成する2つのテーブルの具体的な設計を再確認します。この設計図（マイグレーションファイル）を元に、実際のテーブルを構築していきます。

### 作成するテーブルの仕様

| テーブル名 | 役割 |
| :--- | :--- |
| `categories` | お問い合わせの種類（例: 「商品について」「その他」）を管理するマスターテーブル。 |
| `contacts` | ユーザーから送信されたお問い合わせ情報を格納するメインテーブル。`categories`テーブルと関連付く。 |

### `categories`テーブルのカラム定義

| カラム名 | データ型 | 役割と制約 |
| :--- | :--- | :--- |
| `id` | `BIGINT` (PK) | カテゴリーを一位に識別するためのID。自動で連番が振られる。 |
| `content` | `VARCHAR(255)` | お問い合わせの種類の内容。 |
| `created_at` | `TIMESTAMP` | レコードが作成された日時。 |
| `updated_at` | `TIMESTAMP` | レコードが更新された日時。 |

### `contacts`テーブルのカラム定義

| カラム名 | データ型 | 役割と制約 |
| :--- | :--- | :--- |
| `id` | `BIGINT` (PK) | お問い合わせを一位に識別するためのID。自動で連番が振られる。 |
| `category_id` | `BIGINT` (FK) | `categories`テーブルの`id`と紐づく外部キー。 |
| `first_name` | `VARCHAR(255)` | 姓 |
| `last_name` | `VARCHAR(255)` | 名 |
| `gender` | `TINYINT` | 性別（1:男性, 2:女性, 3:その他） |
| `email` | `VARCHAR(255)` | メールアドレス |
| `tel` | `VARCHAR(11)` | 電話番号（10〜11桁、ハイフンなし） |
| `address` | `VARCHAR(255)` | 住所 |
| `building` | `VARCHAR(255)` | 建物名（NULLを許容） |
| `detail` | `VARCHAR(120)` | お問い合わせ内容（最大120文字） |
| `created_at` | `TIMESTAMP` | レコードが作成された日時。 |
| `updated_at` | `TIMESTAMP` | レコードが更新された日時。 |

## 3. 先輩エンジニアの思考プロセス 💭

なぜこのようなテーブル構造にするのでしょうか？そして、なぜこの順番で実装を進めるのでしょうか？その背景にある設計思想と開発の「型」を理解しましょう。

### Point 1: まず「設計図」から。いきなり実装しない開発スタイル

開発の現場では、思いつきでコードを書き始めることはありません。特にデータベースのようなアプリケーションの根幹に関わる部分では、「まず設計し、チームで合意し、それから実装する」という手順を踏みます。今回のチャプターの流れもまさにその実践です。

1.  **`make:migration`**: まず、何をするかの「宣言」として、からの設計図ファイルを作成します。
2.  **マイグレーションファイルを編集**: 次に、その設計図に具体的なテーブル構造をコードで記述します。
3.  **`migrate`**: 最後に、完成した設計図を元に、実際のデータベースにテーブルを構築します。

この「定義→実行」という流れは、変更内容をGitで管理し、チームメンバーがレビューできるようにするためです。いきなりデータベースを直接操作するのではなく、ワンクッション置くことで、より安全で確実な開発を目指す、これがプロの開発スタイルです。

### Point 2: 「データベースの変更履歴」をすべてコードで管理する

データベースのテーブル構造は、アプリケーションの機能追加や変更に伴って変化していくものです。phpMyAdminのようなGUIツールで直接カラムを追加したり変更したりするのは簡単ですが、その変更は「その場限り」のもので、履歴に残りません。チームメンバーがその変更を知るためには、口頭やチャットで「`contacts`テーブルに`status`カラムを追加しておきました！」と伝えなければならず、伝え忘れや認識齟齬が発生する原因になります。**マイグレーション**を使えば、`2026_02_10_000000_add_status_to_contacts_table.php`のようなファイル名で変更内容が明確に記録されます。このファイルをGitで管理することで、チーム全員がデータベース構造の変更履歴を正確に共有できるのです。これは、属人性を排除し、安定した開発を続けるための基本中の基本です。

### Point 3: 同じ情報は一箇所にまとめる（正規化）

`contacts`テーブルに、お問い合わせの種類を「商品について」のような文字列で直接保存することもできます。しかし、もし「商品について」という文言を「製品について」に変更したくなった場合、`contacts`テーブルにあるすべての該当レコードを更新しなければならず、非常に手間がかかり、更新漏れのリスクもあります。そこで、**正規化**という考え方が重要になります。`categories`という独立したテーブルにお問い合わせの種類をまとめておき、`contacts`テーブルからはそのIDを参照するだけにします。こうすることで、種類の名称を変更したくなった場合でも、`categories`テーブルの1レコードを変更するだけで済み、データの整合性が保たれ、メンテナンス性が格段に向上します。

### Point 4: データ同士の「関連」を明確にし、不正なデータを防ぐ（外部キー制約）

`contacts`テーブルは`categories`テーブルに依存しています。この「関連」をデータベースに明確に教えるのが**外部キー制約**です。`contacts.category_id`には、`categories.id`に存在する値しか登録できない、という制約をかけることができます。これにより、例えば存在しないカテゴリーID（例: 99）を持つお問い合わせデータが誤って登録されてしまう、といったデータ不整合を防ぐことができます。さらに、`onDelete('cascade')`という設定を加えておくと、あるカテゴリー（例: ID=3）を削除した際に、そのカテゴリーに紐づくすべてのお問い合わせデータも自動的に削除してくれます。このように、外部キー制約はデータの整合性を保つための強力な番人として機能します。

### Point 5: データ型は「最小の適切なもの」を選ぶ

データを保存するカラムの「型」を適切に選ぶことは、データベースのパフォーマンスと信頼性に関わります。例えば、「性別」は「男性」「女性」「その他」の3種類しかありません。これを`VARCHAR`型で「男性」のように文字列で保存するより、`TINYINT`（小さな整数を扱う型）を使い、1=男性, 2=女性, 3=その他 のように数値で保存した方が、データサイズが小さくなり、検索速度も向上します。また、電話番号（`tel`）のように、桁数が固定されているデータには、必要最小限の長さ（この場合11桁）を指定することで、データの一貫性を保ち、無駄なストレージを削減できます。同様に、お問い合わせ内容（`detail`）は最大120文字という仕様があるため、`VARCHAR(120)`で十分です。このように、保存するデータの性質と仕様に合わせて最適なデータ型と長さを選択することが、効率的なデータベース設計の第一歩です。

## 4. 実装 🚀

それでは、設計図となるマイグレーションファイルを作成し、テーブルを構築していきましょう。

### 4.1. マイグレーションファイルの作成

まず、`categories`テーブルと`contacts`テーブルの設計図となるファイルを、以下の`sail artisan`コマンドで生成します。

```bash
# categoriesテーブル用のマイグレーションファイルを作成
sail artisan make:migration create_categories_table

# contactsテーブル用のマイグレーションファイルを作成
sail artisan make:migration create_contacts_table
```

このコマンドを実行すると、`database/migrations/`ディレクトリに`YYYY_MM_DD_HHMMSS_create_categories_table.php`のようなファイルが2つ作成されます。

### 4.2. `create_categories_table`マイグレーションの編集

作成された`..._create_categories_table.php`ファイルを開き、`up`メソッドの中身を以下のように編集します。

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('categories', function (Blueprint $table) {
            $table->id();
            $table->string('content', 255);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('categories');
    }
};
```

### 4.3. `create_contacts_table`マイグレーションの編集

次に、`..._create_contacts_table.php`ファイルを開き、`up`メソッドの中身を以下のように編集します。

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('contacts', function (Blueprint $table) {
            $table->id();
            $table->foreignId('category_id')->constrained('categories')->onDelete('cascade');
            $table->string('first_name', 255);
            $table->string('last_name', 255);
            $table->tinyInteger('gender')->comment('1:男性, 2:女性, 3:その他');
            $table->string('email', 255);
            $table->string('tel', 11)->comment('10〜11桁、ハイフンなし');
            $table->string('address', 255);
            $table->string('building', 255)->nullable();
            $table->string('detail', 120);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('contacts');
    }
};
```

### 4.4. マイグレーションの実行

設計図が完成したので、以下のコマンドで実際にデータベースにテーブルを作成します。

```bash
sail artisan migrate
```

このコマンドを実行すると、Laravelはまだ実行されていないマイグレーションファイルを探し出し、`up`メソッドに書かれたコードを実行してテーブルを構築します。phpMyAdmin（`http://localhost:8080`）にアクセスし、`laravel`データベースの中に`categories`と`contacts`テーブルが作成されていれば成功です。

## 5. コードの詳細解説 🔍

マイグレーションファイルに記述したコードが、具体的に何をしているのかを詳しく見ていきましょう。

### `..._create_categories_table.php` の解説

- **`Schema::create('categories', ...)`**
  `categories`という名前の新しいテーブルを作成します。第一引数がテーブル名、第二引数のクロージャ（無名関数）内でテーブルの構造を定義します。

- **`$table->id();`**
  `id`という名前の`BIGINT`型のカラムを作成し、それを主キー（Primary Key）に設定します。さらに、新しいレコードが追加されるたびに自動で数値が増える（オートインクリメント）設定も行います。

- **`$table->string('content', 255);`**
  `content`という名前の`VARCHAR`型のカラムを作成します。第二引数は最大文字数です。`255`は`VARCHAR`型で一般的に使われる最大長です。

- **`$table->timestamps();`**
  `created_at`と`updated_at`という2つの`TIMESTAMP`型のカラムを自動で作成します。これらは、レコードが作成・更新された日時を自動的に記録するために使われ、Laravelのモデル機能と連携して動作します。

### `..._create_contacts_table.php` の解説

- **`$table->foreignId('category_id')->constrained('categories')->onDelete('cascade');`**
  これは外部キー制約を設定する一連のメソッドチェーンです。
  - `foreignId('category_id')`: `category_id`という名前の`BIGINT`型のカラムを作成します。
  - `constrained('categories')`: この`category_id`カラムが、`categories`テーブルの`id`カラムを参照する外部キーであることを定義します。
  - `onDelete('cascade')`: 参照先の`categories`テーブルのレコードが削除された場合、このレコードも一緒に自動で削除（連鎖削除）するよう設定します。

- **`$table->tinyInteger('gender')->comment(...)`**
  `gender`という名前の`TINYINT`（-128から127までの小さな整数）型のカラムを作成します。`comment()`は、データベースにコメントを残す機能で、このカラムがどのような値を持つべきか（1:男性など）をメモしておくのに便利です。

- **`$table->string('building', 255)->nullable();`**
  `building`カラムを作成しますが、`nullable()`メソッドをチェーンすることで、このカラムが空（NULL）であることを許可します。これにより、建物名が任意入力であるという要件を実現しています。

- **`$table->string('detail', 120);`**
  `detail`という名前で、最大120文字の`VARCHAR`型のカラムを作成します。

### 両方のファイルに共通

- **`down()`メソッド**
  `sail artisan migrate:rollback`コマンドが実行されたときに呼び出されます。`up()`メソッドで行った操作を取り消す処理（この場合はテーブルの削除）を記述します。これにより、データベースのバージョンを一つ前に戻すことができます。

## 6. How to: この実装にたどり着くための調べ方 🧐

自力でマイグレーションを実装するための調査プロセスをシミュレーションしてみましょう。

1.  **Step 1: 目的から検索する**
    「**laravel データベース テーブル作成**」というキーワードで検索を開始します。すると、ほとんどの検索結果で「**マイグレーション (Migration)**」という単語が登場することに気づきます。これが最初のとっかかりです。

2.  **Step 2: 専門用語を深掘りする**
    次に「**laravel migration**」で再検索します。すると、Laravelの公式ドキュメントが必ず上位に表示されます。公式ドキュメントの「データベース：マイグレーション」のページを読み進め、`make:migration`コマンドでファイルを作成し、`migrate`コマンドで実行するという基本的な流れを理解します。

3.  **Step 3: 具体的なカラム定義を調べる**
    ドキュメントを読み進めると、「利用可能なカラムのタイプ」というセクションが見つかります。ここで、`id()`, `string()`, `text()`, `timestamps()`といった基本的なカラム作成メソッドの存在を知ることができます。

4.  **Step 4: 未知の要件に対応する**
    「テーブルとテーブルを関連付けたい」という要件が出てきたら、「**laravel migration 外部キー**」や「**laravel migration foreign key**」と検索します。すると、`foreignId()`と`constrained()`メソッドを使った方法を紹介する記事や公式ドキュメントの該当箇所が見つかります。同様に、「任意入力の項目を作りたい」と思ったら「**laravel migration null許可**」と検索すれば、`nullable()`メソッドにたどり着くことができます。

このように、**「目的で検索 → 専門用語を把握 → 公式ドキュメントで基本を学ぶ → 具体的な要件でさらに絞り込み検索」**というサイクルを回すことで、未知の機能でも自力で実装方法を調査できるようになります。

### AIに質問して実装する方法

新しい技術を学ぶ際、AIは強力な学習パートナーになります。ここでは、エンジニアが新しい技術を習得する際の、実務を想定したAIの活用方法を4つのステップで紹介します。

#### Step 1: 公式ドキュメントを読みやすくまとめる

公式ドキュメントは情報が豊富ですが、初学者には難解なことがあります。AIに要点をまとめてもらい、学習の全体像を掴みましょう。

```
以下はLaravelのマイグレーションに関する公式ドキュメントの一部です。これを「実装できるように」分かりやすくまとめてください。

出力してほしい内容：
- 重要ポイント（10行以内）
- 用語の説明（重要なものだけ）
- できること / できないこと（境界をはっきり）
- よくある落とし穴（回避策つき）
- 最小で動かすための手順（コードはまだ不要）

--- ここから ---
（ここにLaravelのマイグレーションに関する公式ドキュメントの一部を貼り付ける）
--- ここまで ---
```

#### Step 2: 「なぜそうなる？」をはっきりさせる（理解を固める）

次に、自分の理解が正しいかを確認し、知識を確かなものにします。

```
Laravelのマイグレーションについて、私の理解はこうです：
「マイグレーションは、SQLを書かずにPHPのコードでデータベースのテーブル構造をバージョン管理するための仕組み。`up`メソッドでテーブル作成や変更を行い、`down`メソッドでその逆の操作を定義する。」

お願い：
1) 正しいかチェックして、間違いがあれば「反例」で教えてください
2) 仕組みを「入力→中で起きること→出力」で説明してください
3) どこまでがこの概念の範囲か（境界）を教えてください
4) よくある勘違いを3つ教えてください
5) 理解チェック問題を3問ください（答えつき）
```

#### Step 3: 実装に落とす（指定フォーマット：手順→解説→例→解説）

知識が固まったら、具体的な実装に進みます。AIに手順やコード例を出力してもらい、実装の解像度を上げます。

```
目的は「カテゴリとお問い合わせを管理するテーブル」の作成です。
制約は「Laravel 10.x, MySQL」です。
前提知識は「PHPの基本的な文法は理解している」です。

次の順番で出力してください：

A. 実装の手順・方針
- まず全体の方針（なぜそのやり方か）
- 手順を1〜Nで（各手順に「できたらOK」の条件も書く）

B. 関連技術の解説
- 必要な関連知識を3〜7個
- 各項目は「一言で説明 → この実装で何に使う → 注意点」

C. 実装例
- まず最小で動く例
- 次に実務向けの拡張例（外部キー制約、NULL許容など）

D. コードの解説
- 重要な部分だけ「何をしてるか」「なぜそう書くか」
- よくあるバグと対策

追加で必要な情報があれば質問していいですが、最大3つまでにしてください。
```

#### Step 4: 設計レビュー（指摘をもらう）

自分で書いたコードや設計案をAIにレビューしてもらい、客観的なフィードバックを得ます。

```
以下の設計をレビューしてください。

- 目的：お問い合わせ管理機能のテーブル設計
- 要件：お問い合わせには必ずカテゴリが紐づく。カテゴリが削除された場合、関連するお問い合わせも削除される。
- 制約：Laravel 10.x, MySQL
- 設計案：
  - `categories`テーブルと`contacts`テーブルを作成
  - `contacts`テーブルに`category_id`カラムを持たせ、`categories`テーブルの`id`への外部キー制約を設定
  - `onDelete(\'cascade\')`を設定
- 不安な点：カテゴリを誤って削除した場合に、お問い合わせまで消えてしまうのが怖い。本当に`cascade`で良いのか迷っている。

見てほしい観点：
- 正しく動くか（抜け漏れ）
- 運用しやすいか（監視/障害対応）
- 変更しやすいか（拡張/分離）
- コスト（開発/運用/性能）
- セキュリティ（権限/秘密情報など）

出力：
- 指摘を「重要度：高/中/低」で出す
- 各指摘に「理由」「影響」「直し方」をつける
- 最後に「この設計が失敗しやすい例」を3つ出す
```

## 7. まとめ ✨

このチャプターでは、Laravelのマイグレーション機能を使って、アプリケーションの土台となるデータベースのテーブルを作成しました。

- **マイグレーションの重要性**: データベースの構造をコードで管理し、チーム内での再現性と変更履歴の追跡を可能にすることの価値を学びました。
- **テーブル設計の基本**: 正規化や外部キー制約といった、データの整合性を保ち、メンテナンス性を高めるための基本的な考え方を理解しました。
- **マイグレーションの実装**: `make:migration`でファイルを作成し、スキーマビルダでカラムを定義し、`migrate`で実行するという一連の流れを実践しました。

これで、アプリケーションがデータを保存するための「器」が用意できました。しかし、まだ器は空っぽで、プログラムから操作する方法もありません。次のチャプターでは、このデータベースのテーブルと対話するための「通訳者」である**モデル**を作成していきます。
