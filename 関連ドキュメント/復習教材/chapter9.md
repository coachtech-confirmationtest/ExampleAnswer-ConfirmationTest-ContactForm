# Chapter 9: アプリケーションの交通整理 - ルーティングでURLと機能を結びつける

## 🎯 このセクションで学ぶこと

このチャプターでは、アプリケーションの「交通整理」役である**ルーティング**について学びます。ユーザーがブラウザで特定のURLにアクセスしたときや、フロントエンドのJavaScriptがAPIを呼び出したときに、どのコントローラーのどのメソッドを呼び出すかを定義するのがルーティングの役割です。URLという「住所」と、コントローラーのアクションという「目的地」を正確に結びつける方法を理解し、アプリケーション全体の血流を設計することがこのチャプターのゴールです。

## 1. はじめに 📖

### ルーティングとは？リクエストを適切な処理に導く「GPSナビゲーション」

ルーティングは、Webアプリケーションにおける「GPSナビゲーションシステム」と考えることができます。ユーザーが「`https://example.com/admin`」という住所（URL）を入力すると、ナビシステムであるルーターは、その住所に最も適したルート（定義されたルート）を検索し、リクエストを「管理画面表示」という目的地（コントローラーのアクション）まで正確に送り届けます。

Laravelでは、このナビシステムの地図が2種類用意されています。

-   **`routes/web.php`**: Webブラウザからの通常のリクエストを処理するための地図。セッション管理やCSRF保護といった、ブラウザ利用を前提とした機能が自動で適用されます。
-   **`routes/api.php`**: JavaScriptからの非同期通信（AJAX）や、外部アプリケーションからのプログラム的なアクセスを処理するための地図。こちらは状態を持たない（ステートレスな）通信を前提としており、よりシンプルな構成になっています。

前チャプターで作成したコントローラーという「目的地」は、まだ地図に載っていないため、どこからもアクセスできません。このチャプターの作業は、これらの目的地を地図に登録し、正しいURLからたどり着けるようにすることです。適切な交通整理を行うことで、アプリケーションは初めて一つのシステムとして機能し始めます。

## 2. 要件の確認 📋

このアプリケーションで必要なルート（URLと機能の結びつき）の要件を整理します。

### Webルート (`routes/web.php`)

| URL | HTTPメソッド | 役割 | 認証 | 関連コントローラー・メソッド |
| :--- | :--- | :--- | :--- | :--- |
| `/` | GET | お問い合わせフォームページを表示する | 不要 | `ContactController@index` |
| `/thanks` | GET | 送信完了ページを表示する | 不要 | `ContactController@thanks` |
| `/admin` | GET | 管理画面ページを表示する | **必要** | `AdminController@index` |

### APIルート (`routes/api.php`)

| URL | HTTPメソッド | 役割 | 認証 | 関連コントローラー・メソッド |
| :--- | :--- | :--- | :--- | :--- |
| `/api/categories` | GET | 全てのカテゴリーを取得する | 不要 | `Api\CategoryController@index` |
| `/api/contacts` | GET | お問い合わせ一覧を取得する | 不要 | `Api\ContactController@index` |
| `/api/contacts` | POST | 新しいお問い合わせを登録する | 不要 | `Api\ContactController@store` |
| `/api/contacts/{contact}` | GET | 特定のお問い合わせを取得する | 不要 | `Api\ContactController@show` |
| `/api/contacts/{contact}` | DELETE | 特定のお問い合わせを削除する | 不要 | `Api\ContactController@destroy` |

## 3. 先輩エンジニアの思考プロセス 💭

効率的で保守性の高いルーティングを設計するために、経験豊富なエンジニアはどのような点を考慮しているのでしょうか。

### Point 1: なぜ`web.php`と`api.php`を使い分けるのか？

Laravelがなぜ2つのルートファイルを用意しているのか、その理由を理解することが重要です。これは「**ミドルウェアグループ**」という概念に基づいています。`routes/web.php`に記述されたルートには、自動的に`web`ミドルウェアグループが適用されます。これには、セッションの開始、CSRFトークンの検証、リクエストデータの整形など、ステートフルな（状態を持つ）ブラウザアプリケーションに必要な機能が含まれています。一方、`routes/api.php`には`api`ミドルウェアグループが適用され、こちらはステートレスな（状態を持たない）通信を前提としたシンプルな構成になっています。このように役割の違うルートを別のファイルに分離することで、設定が混在するのを防ぎ、それぞれの特性に合わせた最適な環境を簡単に適用できるのです。

### Point 2: DRY原則に従い、ルートを「グループ化」する

複数のルートに共通の属性（例えば「認証が必要」）を適用したい場合、一つ一つのルートに同じ設定を書いていくのは非効率で、ミスの元です（Don't Repeat Yourself原則の違反）。このような場合、`Route::middleware(...)`を使ってルートを**グループ化**します。例えば、管理画面に関連するルートはすべて認証が必要なので、`Route::middleware(["auth"])->group(...)`というブロックで囲みます。こうすることで、そのブロック内に記述されたすべてのルートに自動的に認証ミドルウェアが適用され、コードはすっきりと読みやすく、保守性も向上します。

### Point 3: `Route::apiResource`ではなく、個別に定義する理由

CRUD操作のためのルートをまとめて定義できる`Route::apiResource`は非常に便利ですが、今回はあえて個別にルートを定義しています。なぜなら、`apiResource`は7つの標準的なルートを生成しますが、このアプリケーションではその一部しか必要としない、あるいは標準とは異なるURL構造を持ちたい場合があるからです。個別に`Route::get`, `Route::post`と定義することで、アプリケーションに必要なルートだけを過不足なく、かつ明確に記述することができます。特に学習段階では、どのURLがどのコントローラーのアクションに対応しているかを一つ一つ意識することが、理解を深める上で非常に重要です。

## 4. 実装 🚀

`routes/web.php`と`routes/api.php`を編集して、アプリケーションのルートを定義します。

### 4.1. `routes/web.php`の編集

`routes/web.php`を以下のように編集します。デフォルトで書かれているルートは削除して構いません。

```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\ContactController;
use App\Http\Controllers\AdminController;

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
|
| Here is where you can register web routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "web" middleware group. Make something great!
|
*/

// お問い合わせフォーム
Route::get("/", [ContactController::class, "index"]);

// お問い合わせ完了
Route::get("/thanks", [ContactController::class, "thanks"]);

// 管理画面（認証必須）
Route::middleware("auth")->group(function () {
    Route::get("/admin", [AdminController::class, "index"]);
});
```

### 4.2. `routes/api.php`の編集

`routes/api.php`を以下のように編集します。

```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\Api\ContactController;
use App\Http\Controllers\Api\CategoryController;
/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
|
| Here is where you can register API routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "api" middleware group. Make something great!
|
*/

// カテゴリー一覧
Route::get("/categories", [CategoryController::class, "index"]);

// お問い合わせ一覧
Route::get("/contacts", [ContactController::class, "index"]);
// お問い合わせ登録
Route::post("/contacts", [ContactController::class, "store"]);
// お問い合わせ詳細
Route::get("/contacts/{contact}", [ContactController::class, "show"]);
// お問い合わせ削除
Route::delete("/contacts/{contact}", [ContactController::class, "destroy"]);
```

## 5. コードの詳細解説 🔍

### `routes/web.php` の解説

- **`Route::get("/"), [ContactController::class, "index"])`**
  - **何をしているか**: HTTPのGETメソッドでルートURL (`/`) にアクセスがあった場合、`App\Http\Controllers\ContactController`クラスの`index`メソッドを呼び出す、という定義です。
  - **なぜそう書くか**: `[クラス名, メソッド名]`という配列形式の記法は、Laravel 8から標準となった書き方で、IDEの補完が効きやすく、タイプミスを防げるメリットがあります。

- **`Route::middleware(["auth"])->group(...)`**
  - **何をしているか**: このグループ内のルート（今回は`/admin`）にアクセスするには、`auth`ミドルウェアによる認証（ログインしていること）が必要になります。
  - **なぜそう書くか**: 複数のルートに同じミドルウェアを適用したい場合に、`group`でまとめることでコードの重複をなくし、保守性を高めます。ログインしていないユーザーが`/admin`にアクセスすると、自動的にログインページにリダイレクトされます。

### `routes/api.php` の解説

- **`Route::get("/contacts/{contact}"), ...)`**
  - **何をしているか**: URLの一部に`{contact}`というプレースホルダーを含んでいます。これは**ルートモデルバインディング**という機能で、LaravelはURLの`{contact}`部分にあるIDを使って、自動的に`Contact`モデルのインスタンスを検索し、コントローラーの`show(Contact $contact)`や`destroy(Contact $contact)`メソッドに渡してくれます。
  - **なぜそう書くか**: コントローラー側で`Contact::find($id)`のような定型コードを書く必要がなくなり、コードがよりクリーンで宣言的になります。

## 6. How to: この実装にたどり着くための調べ方 🗺️

ここでは、あなたが一人で新しい技術を学ぶ際に、AIをどのように活用すれば効率的かを、4つのステップで紹介します。

### Step 1: 公式ドキュメントを読みやすくまとめる

まずは、公式ドキュメントという一次情報をAIに要約してもらい、全体像を素早く掴みます。

> **プロンプト例**
> 
> 以下はLaravelの公式ドキュメントの一部です。 これを「実装できるように」分かりやすくまとめてください。
> 
> 出力してほしい内容：
> - 重要ポイント（10行以内）
> - 用語の説明（重要なものだけ）
> - できること / できないこと（境界をはっきり）
> - よくある落とし穴（回避策つき）
> - 最小で動かすための手順（コードはまだ不要）
> 
> --- ここから ---
> https://laravel.com/docs/10.x/routing
> （ここに公式ドキュメントのURLや内容を貼り付ける）
> --- ここまで ---

### Step 2: 「なぜそうなる？」をはっきりさせる（理解を固める）

次に、自分の理解が正しいかを確認し、技術の「なぜ」を深く理解します。

> **プロンプト例**
> 
> Laravelのルーティングについて、私の理解はこうです：
> 「`routes/web.php`はブラウザ用、`routes/api.php`はプログラム用で、それぞれにミドルウェアという設定が自動で適用される。URLに`{}`を使うと、その部分の値をコントローラーで受け取れる。」
> 
> お願い：
> 1) 正しいかチェックして、間違いがあれば「反例」で教えてください
> 2) ミドルウェアグループの仕組みを「入力→中で起きること→出力」で説明してください
> 3) ルートモデルバインディングはどこまでがこの概念の範囲か（境界）を教えてください
> 4) よくある勘違いを3つ教えてください
> 5) 理解チェック問題を3問ください（答えつき）

### Step 3: 実装に落とす（指定フォーマット：手順→解説→例→解説）

概念を理解したら、具体的な実装方法をAIに聞き、コードに落とし込みます。

> **プロンプト例**
> 
> 目的は、管理画面(`/admin`)へのアクセスを認証済みユーザーのみに制限することです。
> 前提知識はPHPとLaravelのコントローラーの基本です。
> 
> 次の順番で出力してください：
> 
> A. 実装の手順・方針
>  - まず全体の方針（なぜそのやり方か）
>  - 手順を1〜Nで（各手順に「できたらOK」の条件も書く）
> 
> B. 関連技術の解説
>  - 必要な関連知識を3〜7個（例: ミドルウェア、ルートグループ）
>  - 各項目は「一言で説明 → この実装で何に使う → 注意点」
> 
> C. 実装例
>  - まず最小で動く例
>  - 次に実務向けの拡張例（複数のルートをグループ化する例など）
> 
> D. コードの解説
>  - 重要な部分だけ「何をしてるか」「なぜそう書くか」
>  - よくあるバグと対策

### Step 4: 設計レビュー（指摘をもらう）

最後に、自分の書いたコードや設計をAIにレビューしてもらい、改善点を見つけます。

> **プロンプト例**
> 
> 以下のルーティング設計をレビューしてください。
> 
> - 目的：お問い合わせ管理システムのルート定義
> - 要件：Webページ表示とCRUD操作のAPIが必要
> - 制約：Laravel 10.x
> - 設計案：
> ```php
> // web.php
> Route::get('/', [ContactController::class, 'index']);
> Route::get('/admin', [AdminController::class, 'index'])->middleware('auth');
> 
> // api.php
> Route::apiResource('contacts', ApiContactController::class);
> ```
> - 不安な点：`apiResource`を全て使うのは冗長ではないか？Web側のルートはグループ化すべきか？
> 
> 見てほしい観点：
> - 保守性（ルートが増えた時に管理しやすいか）
> - 一貫性（命名規則やURL構造は適切か）
> - セキュリティ（不要なルートが公開されていないか）
> 
> 出力：
> - 指摘を「重要度：高/中/低」で出す
> - 各指摘に「理由」「影響」「直し方」をつける
> - 最後に「この設計が失敗しやすい例」を3つ出す

## 7. まとめ ✨

このチャプターでは、アプリケーションの交通網であるルーティングを定義しました。

-   **ルーティングの役割**: URLとコントローラーのアクションを結びつけ、リクエストを適切な処理に導く「GPSナビゲーション」であることを学びました。
-   **`web.php`と`api.php`**: ブラウザ向けの`web.php`と、プログラム向けの`api.php`という2つのルートファイルを、それぞれの役割に応じて使い分けました。
-   **ルートモデルバインディング**: URLのパラメータから自動でモデルを取得する便利な機能を活用しました。

これで、バックエンドのすべての部品（モデル、ビュー、コントローラー、ルート）が繋がり、アプリケーションの骨格が完成しました。次の最終チャプターでは、実際にアプリケーションを動かし、正しく機能するかを確認する「動作確認」を行います。
